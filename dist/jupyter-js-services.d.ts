// Generated by dts-bundle v0.3.0

import { Kernel } from '__jupyter-js-services/--/build/kernel';
import { NotebookSession } from '__jupyter-js-services/--/build/session';
export * from "__jupyter-js-services/--/build/kernel";
export * from "__jupyter-js-services/--/build/session";
declare var _default: {
    Kernel: typeof Kernel;
    NotebookSession: typeof NotebookSession;
};
export default _default;

import ISignal = phosphor.core.ISignal;
import IDisposable = phosphor.utility.IDisposable;
/**
    * Kernel message header content.
    */
export interface IKernelMsgHeader {
        username: string;
        version: string;
        session: string;
        msgId: string;
        msgType: string;
}
/**
    * Kernel message specification.
    */
export interface IKernelMsg {
        header: IKernelMsgHeader;
        metadata: any;
        content: any;
        parentHeader: {} | IKernelMsgHeader;
        msgId?: string;
        msgType?: string;
        channel?: string;
        buffers?: string[] | ArrayBuffer[];
}
/**
    * Settings for a kernel execute command.
    */
export interface IKernelExecute {
        silent?: boolean;
        user_expressions?: any;
        allow_stdin?: boolean;
        store_history?: boolean;
}
/**
    * Kernel identification specification.
    */
export interface IKernelId {
        id: string;
        name: string;
}
/**
    * Kernel information specification.
    * http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info
    */
export interface IKernelInfo {
        protocol_version: string;
        implementation: string;
        implementation_version: string;
        language_info: IKernelLanguageInfo;
        banner: string;
        help_links: {
                [key: string]: string;
        };
}
/**
    * Kernel language information specification.
    */
export interface IKernelLanguageInfo {
        name: string;
        version: string;
        mimetype: string;
        file_extension: string;
        pygments_lexer: string;
        codemirror_mode: string | {};
        nbconverter_exporter: string;
}
/**
    * Object providing a Future interface for message callbacks.
    *
    * Only one callback can be registered per type.
    * If `autoDispose` is set, the future will self-dispose after `isDone` is
    * set and the registered `onDone` handler is called.
    *
    * The Future is considered done when a `reply` message and a
    * an `idle` iopub status message have been received.
    */
export interface IKernelFuture extends IDisposable {
        /**
            * The autoDispose behavior of the future.
            *
            * If True, it will self-dispose() after onDone() is called.
            */
        autoDispose: boolean;
        /**
            * Set when the message is done.
            */
        isDone: boolean;
        /**
            * Register a reply handler. Returns `this`.
            */
        onReply(cb: (msg: IKernelMsg) => void): IKernelFuture;
        /**
            * Register an output handler. Returns `this`.
            */
        onOutput(cb: (msg: IKernelMsg) => void): IKernelFuture;
        /**
            * Register a done handler. Returns `this`.
            */
        onDone(cb: (msg: IKernelMsg) => void): IKernelFuture;
        /**
            * Register an input handler. Returns `this`.
            */
        onInput(cb: (msg: IKernelMsg) => void): IKernelFuture;
}
/**
    * A class to communicate with the Python kernel. This
    * should generally not be constructed directly, but be created
    * by the `Session` object. Once created, this object should be
    * used to communicate with the kernel.
    */
export declare class Kernel {
        /**
            * A signal emitted when the kernel changes state.
            */
        statusChanged: ISignal<string>;
        /**
            * GET /api/kernels
            *
            * Get the list of running kernels.
            */
        static list(baseUrl: string): Promise<IKernelId[]>;
        /**
            * Construct a new kernel.
            */
        constructor(baseUrl: string, wsUrl: string);
        /**
            * Set the name of the kernel.
            */
        name: string;
        /**
            * Check whether there is a connection to the kernel. This
            * function only returns true if websocket has been
            * created and has a state of WebSocket.OPEN.
            */
        isConnected: boolean;
        /**
            * Check whether the connection to the kernel has been completely
            * severed. This function only returns true if the websocket is null.
            */
        isFullyDisconnected: boolean;
        /**
            * Get the Info Reply Message from the kernel.
            */
        infoReply: IKernelInfo;
        /**
            * Get the current status of the kernel.
            */
        status: string;
        /**
            * Set the current id of the kernel.
            */
        id: string;
        /**
            * Get the full websocket url.
            */
        wsUrl: string;
        /**
            * GET /api/kernels/[:kernel_id]
            *
            * Get information about the kernel.
            */
        getInfo(): Promise<IKernelId>;
        /**
            * POST /api/kernels/[:kernel_id]/interrupt
            *
            * Interrupt the kernel.
            */
        interrupt(): Promise<void>;
        /**
            * POST /api/kernels/[:kernel_id]/restart
            *
            * Restart the kernel.
            */
        restart(): Promise<IKernelId>;
        /**
            * POST /api/kernels/[:kernel_id]
            *
            * Start a kernel.  Note: if using a session, Session.start()
            * should be used instead.
            */
        start(id?: IKernelId): Promise<IKernelId>;
        /**
            * DELETE /api/kernels/[:kernel_id]
            *
            * Kill a kernel. Note: if useing a session, Session.delete()
            * should be used instead.
            */
        delete(): Promise<void>;
        /**
            * Connect to the server-side the kernel.
            *
            * This should only be called directly by a session.
            */
        connect(id?: IKernelId): void;
        /**
            * Reconnect to a disconnected kernel. This is not actually a
            * standard HTTP request, but useful function nonetheless for
            * reconnecting to the kernel if the connection is somehow lost.
            */
        reconnect(): void;
        /**
            * Disconnect the kernel.
            */
        disconnect(): void;
        /**
            * Send a message on the kernel's shell channel.
            */
        sendShellMessage(msg_type: string, content: any, metadata?: {}, buffers?: string[]): IKernelFuture;
        /**
            * Get kernel info.
            *
            * Returns a KernelFuture that will resolve to a `kernel_info_reply` message documented
            * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info)
            */
        kernelInfo(): IKernelFuture;
        /**
            * Get info on an object.
            *
            * Returns a KernelFuture that will resolve to a `inspect_reply` message documented
            * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#object-information)
            */
        inspect(code: string, cursor_pos: number): IKernelFuture;
        /**
            * Execute given code into kernel, returning a KernelFuture.
            *
            * @example
            *
            * The options object should contain the options for the execute
            * call. Its default values are:
            *
            *      options = {
            *        silent : true,
            *        user_expressions : {},
            *        allow_stdin : false,
                            store_history: false
            *      }
            *
            */
        execute(code: string, options?: IKernelExecute): IKernelFuture;
        /**
            * Request a code completion from the kernel.
            *
            * Returns a KernelFuture with will resolve to a `complete_reply` documented
            * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#complete)
            */
        complete(code: string, cursor_pos: number): IKernelFuture;
        /**
            * Send an input reply message to the kernel.
            *
            * TODO: how to handle this?  Right now called by
            * ./static/notebook/js/outputarea.js:827:
            * this.events.trigger('send_input_reply.Kernel', value);
            *
            * which has no reference to the session or the kernel
            */
        sendInputReply(input: any): string;
}
export declare class KernelSub extends Kernel {
        doSomething(): void;
}
/**
    * Validate an object as being of IKernelID type
    */
export declare function validateKernelId(info: IKernelId): void;

import ISignal = phosphor.core.ISignal;
import { IKernelId, Kernel } from '__jupyter-js-services/--/build/kernel';
/**
    * Notebook Identification specification.
    */
export interface INotebookId {
        path: string;
}
/**
    * Session Identification specification.
    */
export interface ISessionId {
        id: string;
        notebook: INotebookId;
        kernel: IKernelId;
}
/**
    * Session initialization options.
    */
export interface ISessionOptions {
        notebookPath: string;
        kernelName: string;
        baseUrl: string;
        wsUrl: string;
}
/**
    * Session object for accessing the session REST api. The session
    * should be used to start kernels and then shut them down -- for
    * all other operations, the kernel object should be used.
    **/
export declare class NotebookSession {
        /**
            * A signal emitted when the session changes state.
            */
        statusChanged: ISignal<string>;
        /**
            * GET /api/sessions
            *
            * Get a list of the current sessions.
            */
        static list(baseUrl: string): Promise<ISessionId[]>;
        /**
            * Construct a new session.
            */
        constructor(options: ISessionOptions);
        /**
            * Get the session kernel object.
         */
        kernel: Kernel;
        /**
            * POST /api/sessions
            *
            * Start a new session. This function can only be successfully executed once.
            */
        start(): Promise<ISessionId>;
        /**
            * GET /api/sessions/[:session_id]
            *
            * Get information about a session.
            */
        getInfo(): Promise<ISessionId>;
        /**
            * DELETE /api/sessions/[:session_id]
            *
            * Kill the kernel and shutdown the session.
            */
        delete(): Promise<void>;
        /**
            * Restart the session by deleting it and then starting it fresh.
            */
        restart(options?: ISessionOptions): Promise<void>;
        /**
            * Rename the notebook.
            */
        renameNotebook(path: string): Promise<ISessionId>;
}

